[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar meteorInstall = Package.modules.meteorInstall;\nvar process = Package.modules.process;\nvar Promise = Package.promise.Promise;\nvar DDP = Package['ddp-client'].DDP;\nvar DDPServer = Package['ddp-server'].DDPServer;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\nvar Symbol = Package['ecmascript-runtime-server'].Symbol;\nvar Map = Package['ecmascript-runtime-server'].Map;\nvar Set = Package['ecmascript-runtime-server'].Set;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"dynamic-import\":{\"server.js\":function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                              //\n// packages/dynamic-import/server.js                                                                            //\n//                                                                                                              //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                //\nvar _toConsumableArray2 = require(\"babel-runtime/helpers/toConsumableArray\");                                   //\n                                                                                                                //\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);                                          //\n                                                                                                                //\nvar _typeof2 = require(\"babel-runtime/helpers/typeof\");                                                         //\n                                                                                                                //\nvar _typeof3 = _interopRequireDefault(_typeof2);                                                                //\n                                                                                                                //\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }               //\n                                                                                                                //\nvar module1 = module;                                                                                           // 1\nvar assert = void 0;                                                                                            // 1\nmodule1.watch(require(\"assert\"), {                                                                              // 1\n  \"default\": function (v) {                                                                                     // 1\n    assert = v;                                                                                                 // 1\n  }                                                                                                             // 1\n}, 0);                                                                                                          // 1\nvar readFileSync = void 0;                                                                                      // 1\nmodule1.watch(require(\"fs\"), {                                                                                  // 1\n  readFileSync: function (v) {                                                                                  // 1\n    readFileSync = v;                                                                                           // 1\n  }                                                                                                             // 1\n}, 1);                                                                                                          // 1\nvar pathJoin = void 0,                                                                                          // 1\n    pathNormalize = void 0;                                                                                     // 1\nmodule1.watch(require(\"path\"), {                                                                                // 1\n  join: function (v) {                                                                                          // 1\n    pathJoin = v;                                                                                               // 1\n  },                                                                                                            // 1\n  normalize: function (v) {                                                                                     // 1\n    pathNormalize = v;                                                                                          // 1\n  }                                                                                                             // 1\n}, 2);                                                                                                          // 1\nvar check = void 0;                                                                                             // 1\nmodule1.watch(require(\"meteor/check\"), {                                                                        // 1\n  check: function (v) {                                                                                         // 1\n    check = v;                                                                                                  // 1\n  }                                                                                                             // 1\n}, 3);                                                                                                          // 1\nmodule1.watch(require(\"./security.js\"));                                                                        // 1\nmodule1.watch(require(\"./client.js\"));                                                                          // 1\nvar hasOwn = Object.prototype.hasOwnProperty;                                                                   // 13\nObject.keys(dynamicImportInfo).forEach(function (platform) {                                                    // 15\n  var info = dynamicImportInfo[platform];                                                                       // 16\n                                                                                                                //\n  if (info.dynamicRoot) {                                                                                       // 17\n    info.dynamicRoot = pathNormalize(info.dynamicRoot);                                                         // 18\n  }                                                                                                             // 19\n});                                                                                                             // 20\nMeteor.methods({                                                                                                // 22\n  __dynamicImport: function (tree) {                                                                            // 23\n    check(tree, Object);                                                                                        // 24\n    this.unblock();                                                                                             // 25\n    var platform = this.connection ? \"web.browser\" : \"server\";                                                  // 27\n    var pathParts = [];                                                                                         // 28\n                                                                                                                //\n    function walk(node) {                                                                                       // 30\n      if (node && (typeof node === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(node)) === \"object\") {     // 31\n        Object.keys(node).forEach(function (name) {                                                             // 32\n          pathParts.push(name);                                                                                 // 33\n          node[name] = walk(node[name]);                                                                        // 34\n          assert.strictEqual(pathParts.pop(), name);                                                            // 35\n        });                                                                                                     // 36\n      } else {                                                                                                  // 37\n        return read(pathParts, platform);                                                                       // 38\n      }                                                                                                         // 39\n                                                                                                                //\n      return node;                                                                                              // 40\n    }                                                                                                           // 41\n                                                                                                                //\n    return walk(tree);                                                                                          // 43\n  }                                                                                                             // 44\n});                                                                                                             // 22\n                                                                                                                //\nfunction read(pathParts, platform) {                                                                            // 47\n  var dynamicRoot = dynamicImportInfo[platform].dynamicRoot;                                                    // 47\n  var absPath = pathNormalize(pathJoin(dynamicRoot, pathJoin.apply(undefined, (0, _toConsumableArray3.default)(pathParts)).replace(/:/g, \"_\")));\n                                                                                                                //\n  if (!absPath.startsWith(dynamicRoot)) {                                                                       // 54\n    throw new Meteor.Error(\"bad dynamic module path\");                                                          // 55\n  }                                                                                                             // 56\n                                                                                                                //\n  var cache = getCache(platform);                                                                               // 58\n  return hasOwn.call(cache, absPath) ? cache[absPath] : cache[absPath] = readFileSync(absPath, \"utf8\");         // 59\n}                                                                                                               // 62\n                                                                                                                //\nvar cachesByPlatform = Object.create(null);                                                                     // 64\n                                                                                                                //\nfunction getCache(platform) {                                                                                   // 65\n  return hasOwn.call(cachesByPlatform, platform) ? cachesByPlatform[platform] : cachesByPlatform[platform] = Object.create(null);\n}                                                                                                               // 69\n                                                                                                                //\nprocess.on(\"message\", function (msg) {                                                                          // 71\n  // The cache for the \"web.browser\" platform needs to be discarded                                             // 72\n  // whenever a client-only refresh occurs, so that new client code does                                        // 73\n  // not receive stale module data from __dynamicImport. This code handles                                      // 74\n  // the same message listened for by the autoupdate package.                                                   // 75\n  if (msg && msg.refresh === \"client\") {                                                                        // 76\n    delete cachesByPlatform[\"web.browser\"];                                                                     // 77\n  }                                                                                                             // 78\n});                                                                                                             // 79\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"cache.js\":function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                              //\n// packages/dynamic-import/cache.js                                                                             //\n//                                                                                                              //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                //\nvar hasOwn = Object.prototype.hasOwnProperty;                                                                   // 1\nvar dbPromise;                                                                                                  // 2\nvar canUseCache = // The server doesn't benefit from dynamic module fetching, and almost                        // 4\n// certainly doesn't support IndexedDB.                                                                         // 6\nMeteor.isClient && // Cordova bundles all modules into the monolithic initial bundle, so                        // 7\n// the dynamic module cache won't be necessary.                                                                 // 9\n!Meteor.isCordova && // Caching can be confusing in development, and is designed to be a                        // 10\n// transparent optimization for production performance.                                                         // 12\nMeteor.isProduction;                                                                                            // 13\n                                                                                                                //\nfunction getIDB() {                                                                                             // 15\n  if (typeof indexedDB !== \"undefined\") return indexedDB;                                                       // 16\n  if (typeof webkitIndexedDB !== \"undefined\") return webkitIndexedDB;                                           // 17\n  if (typeof mozIndexedDB !== \"undefined\") return mozIndexedDB;                                                 // 18\n  if (typeof OIndexedDB !== \"undefined\") return OIndexedDB;                                                     // 19\n  if (typeof msIndexedDB !== \"undefined\") return msIndexedDB;                                                   // 20\n}                                                                                                               // 21\n                                                                                                                //\nfunction withDB(callback) {                                                                                     // 23\n  dbPromise = dbPromise || new Promise(function (resolve, reject) {                                             // 24\n    var idb = getIDB();                                                                                         // 25\n                                                                                                                //\n    if (!idb) {                                                                                                 // 26\n      throw new Error(\"IndexedDB not available\");                                                               // 27\n    } // Incrementing the version number causes all existing object stores                                      // 28\n    // to be deleted and recreates those specified by objectStoreMap.                                           // 31\n                                                                                                                //\n                                                                                                                //\n    var request = idb.open(\"MeteorDynamicImportCache\", 2);                                                      // 32\n                                                                                                                //\n    request.onupgradeneeded = function (event) {                                                                // 34\n      var db = event.target.result; // It's fine to delete existing object stores since onupgradeneeded         // 35\n      // is only called when we change the DB version number, and the data                                      // 38\n      // we're storing is disposable/reconstructible.                                                           // 39\n                                                                                                                //\n      Array.from(db.objectStoreNames).forEach(db.deleteObjectStore, db);                                        // 40\n      Object.keys(objectStoreMap).forEach(function (name) {                                                     // 42\n        db.createObjectStore(name, objectStoreMap[name]);                                                       // 43\n      });                                                                                                       // 44\n    };                                                                                                          // 45\n                                                                                                                //\n    request.onerror = makeOnError(reject, \"indexedDB.open\");                                                    // 47\n                                                                                                                //\n    request.onsuccess = function (event) {                                                                      // 48\n      resolve(event.target.result);                                                                             // 49\n    };                                                                                                          // 50\n  });                                                                                                           // 51\n  return dbPromise.then(callback, function (error) {                                                            // 53\n    return callback(null);                                                                                      // 54\n  });                                                                                                           // 55\n}                                                                                                               // 56\n                                                                                                                //\nvar objectStoreMap = {                                                                                          // 58\n  sourcesByVersion: {                                                                                           // 59\n    keyPath: \"version\"                                                                                          // 59\n  }                                                                                                             // 59\n};                                                                                                              // 58\n                                                                                                                //\nfunction makeOnError(reject, source) {                                                                          // 62\n  return function (event) {                                                                                     // 63\n    reject(new Error(\"IndexedDB failure in \" + source + \" \" + JSON.stringify(event.target))); // Returning true from an onerror callback function prevents an\n    // InvalidStateError in Firefox during Private Browsing. Silencing                                          // 70\n    // that error is safe because we handle the error more gracefully by                                        // 71\n    // passing it to the Promise reject function above.                                                         // 72\n    // https://github.com/meteor/meteor/issues/8697                                                             // 73\n                                                                                                                //\n    return true;                                                                                                // 74\n  };                                                                                                            // 75\n}                                                                                                               // 76\n                                                                                                                //\nvar checkCount = 0;                                                                                             // 78\n                                                                                                                //\nexports.checkMany = function (versions) {                                                                       // 80\n  var ids = Object.keys(versions);                                                                              // 81\n  var sourcesById = Object.create(null); // Initialize sourcesById with null values to indicate all sources are\n  // missing (unless replaced with actual sources below).                                                       // 85\n                                                                                                                //\n  ids.forEach(function (id) {                                                                                   // 86\n    sourcesById[id] = null;                                                                                     // 87\n  });                                                                                                           // 88\n                                                                                                                //\n  if (!canUseCache) {                                                                                           // 90\n    return Promise.resolve(sourcesById);                                                                        // 91\n  }                                                                                                             // 92\n                                                                                                                //\n  return withDB(function (db) {                                                                                 // 94\n    if (!db) {                                                                                                  // 95\n      // We thought we could used IndexedDB, but something went wrong                                           // 96\n      // while opening the database, so err on the side of safety.                                              // 97\n      return sourcesById;                                                                                       // 98\n    }                                                                                                           // 99\n                                                                                                                //\n    var txn = db.transaction([\"sourcesByVersion\"], \"readonly\");                                                 // 101\n    var sourcesByVersion = txn.objectStore(\"sourcesByVersion\");                                                 // 105\n    ++checkCount;                                                                                               // 107\n                                                                                                                //\n    function finish() {                                                                                         // 109\n      --checkCount;                                                                                             // 110\n      return sourcesById;                                                                                       // 111\n    }                                                                                                           // 112\n                                                                                                                //\n    return Promise.all(ids.map(function (id) {                                                                  // 114\n      return new Promise(function (resolve, reject) {                                                           // 115\n        var version = versions[id];                                                                             // 116\n                                                                                                                //\n        if (version) {                                                                                          // 117\n          var sourceRequest = sourcesByVersion.get(versions[id]);                                               // 118\n          sourceRequest.onerror = makeOnError(reject, \"sourcesByVersion.get\");                                  // 119\n                                                                                                                //\n          sourceRequest.onsuccess = function (event) {                                                          // 120\n            var result = event.target.result;                                                                   // 121\n                                                                                                                //\n            if (result) {                                                                                       // 122\n              sourcesById[id] = result.source;                                                                  // 123\n            }                                                                                                   // 124\n                                                                                                                //\n            resolve();                                                                                          // 125\n          };                                                                                                    // 126\n        } else resolve();                                                                                       // 127\n      });                                                                                                       // 128\n    })).then(finish, finish);                                                                                   // 129\n  });                                                                                                           // 130\n};                                                                                                              // 131\n                                                                                                                //\nvar pendingVersionsAndSourcesById = Object.create(null);                                                        // 133\n                                                                                                                //\nexports.setMany = function (versionsAndSourcesById) {                                                           // 135\n  if (canUseCache) {                                                                                            // 136\n    Object.assign(pendingVersionsAndSourcesById, versionsAndSourcesById); // Delay the call to flushSetMany so that it doesn't contribute to the\n    // amount of time it takes to call module.dynamicImport.                                                    // 143\n                                                                                                                //\n    if (!flushSetMany.timer) {                                                                                  // 144\n      flushSetMany.timer = setTimeout(flushSetMany, 100);                                                       // 145\n    }                                                                                                           // 146\n  }                                                                                                             // 147\n};                                                                                                              // 148\n                                                                                                                //\nfunction flushSetMany() {                                                                                       // 150\n  if (checkCount > 0) {                                                                                         // 151\n    // If checkMany is currently underway, postpone the flush until later,                                      // 152\n    // since updating the cache is less important than reading from it.                                         // 153\n    return flushSetMany.timer = setTimeout(flushSetMany, 100);                                                  // 154\n  }                                                                                                             // 155\n                                                                                                                //\n  flushSetMany.timer = null;                                                                                    // 157\n  var versionsAndSourcesById = pendingVersionsAndSourcesById;                                                   // 159\n  pendingVersionsAndSourcesById = Object.create(null);                                                          // 160\n  return withDB(function (db) {                                                                                 // 162\n    if (!db) {                                                                                                  // 163\n      // We thought we could used IndexedDB, but something went wrong                                           // 164\n      // while opening the database, so err on the side of safety.                                              // 165\n      return;                                                                                                   // 166\n    }                                                                                                           // 167\n                                                                                                                //\n    var setTxn = db.transaction([\"sourcesByVersion\"], \"readwrite\");                                             // 169\n    var sourcesByVersion = setTxn.objectStore(\"sourcesByVersion\");                                              // 173\n    return Promise.all(Object.keys(versionsAndSourcesById).map(function (id) {                                  // 175\n      var info = versionsAndSourcesById[id];                                                                    // 177\n      return new Promise(function (resolve, reject) {                                                           // 178\n        var request = sourcesByVersion.put({                                                                    // 179\n          version: info.version,                                                                                // 180\n          source: info.source                                                                                   // 181\n        });                                                                                                     // 179\n        request.onerror = makeOnError(reject, \"sourcesByVersion.put\");                                          // 183\n        request.onsuccess = resolve;                                                                            // 184\n      });                                                                                                       // 185\n    }));                                                                                                        // 186\n  });                                                                                                           // 188\n}                                                                                                               // 189\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"client.js\":function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                              //\n// packages/dynamic-import/client.js                                                                            //\n//                                                                                                              //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                //\nvar _typeof2 = require(\"babel-runtime/helpers/typeof\");                                                         //\n                                                                                                                //\nvar _typeof3 = _interopRequireDefault(_typeof2);                                                                //\n                                                                                                                //\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }               //\n                                                                                                                //\nvar Module = module.constructor;                                                                                // 1\n                                                                                                                //\nvar cache = require(\"./cache.js\"); // Call module.dynamicImport(id) to fetch a module and any/all of its        // 2\n// dependencies that have not already been fetched, and evaluate them as                                        // 5\n// soon as they arrive. This runtime API makes it very easy to implement                                        // 6\n// ECMAScript dynamic import(...) syntax.                                                                       // 7\n                                                                                                                //\n                                                                                                                //\nModule.prototype.dynamicImport = function (id) {                                                                // 8\n  var module = this;                                                                                            // 9\n  return module.prefetch(id).then(function () {                                                                 // 10\n    return getNamespace(module, id);                                                                            // 11\n  });                                                                                                           // 12\n}; // Called by Module.prototype.prefetch if there are any missing dynamic                                      // 13\n// modules that need to be fetched.                                                                             // 16\n                                                                                                                //\n                                                                                                                //\nmeteorInstall.fetch = function (ids) {                                                                          // 17\n  var tree = Object.create(null);                                                                               // 18\n  var versions = Object.create(null);                                                                           // 19\n                                                                                                                //\n  var dynamicVersions = require(\"./dynamic-versions.js\");                                                       // 20\n                                                                                                                //\n  var missing;                                                                                                  // 21\n  Object.keys(ids).forEach(function (id) {                                                                      // 23\n    var version = getFromTree(dynamicVersions, id);                                                             // 24\n                                                                                                                //\n    if (version) {                                                                                              // 25\n      versions[id] = version;                                                                                   // 26\n    } else {                                                                                                    // 27\n      addToTree(missing = missing || Object.create(null), id, 1);                                               // 28\n    }                                                                                                           // 29\n  });                                                                                                           // 30\n  return cache.checkMany(versions).then(function (sources) {                                                    // 32\n    Object.keys(sources).forEach(function (id) {                                                                // 33\n      var source = sources[id];                                                                                 // 34\n                                                                                                                //\n      if (source) {                                                                                             // 35\n        var info = ids[id];                                                                                     // 36\n        addToTree(tree, id, makeModuleFunction(id, source, info.options));                                      // 37\n      } else {                                                                                                  // 38\n        addToTree(missing = missing || Object.create(null), id, 1);                                             // 39\n      }                                                                                                         // 40\n    });                                                                                                         // 41\n    return missing && fetchMissing(missing).then(function (results) {                                           // 43\n      var versionsAndSourcesById = Object.create(null);                                                         // 44\n      var flatResults = flattenModuleTree(results);                                                             // 45\n      Object.keys(flatResults).forEach(function (id) {                                                          // 47\n        var source = flatResults[id];                                                                           // 48\n        var info = ids[id];                                                                                     // 49\n        addToTree(tree, id, makeModuleFunction(id, source, info.options));                                      // 51\n        var version = getFromTree(dynamicVersions, id);                                                         // 53\n                                                                                                                //\n        if (version) {                                                                                          // 54\n          versionsAndSourcesById[id] = {                                                                        // 55\n            version: version,                                                                                   // 56\n            source: source                                                                                      // 57\n          };                                                                                                    // 55\n        }                                                                                                       // 59\n      });                                                                                                       // 60\n      cache.setMany(versionsAndSourcesById);                                                                    // 62\n    });                                                                                                         // 63\n  }).then(function () {                                                                                         // 65\n    return tree;                                                                                                // 66\n  });                                                                                                           // 67\n};                                                                                                              // 68\n                                                                                                                //\nfunction flattenModuleTree(tree) {                                                                              // 70\n  var parts = [\"\"];                                                                                             // 71\n  var result = Object.create(null);                                                                             // 72\n                                                                                                                //\n  function walk(t) {                                                                                            // 74\n    if (t && (typeof t === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(t)) === \"object\") {                // 75\n      Object.keys(t).forEach(function (key) {                                                                   // 76\n        parts.push(key);                                                                                        // 77\n        walk(t[key]);                                                                                           // 78\n        parts.pop();                                                                                            // 79\n      });                                                                                                       // 80\n    } else if (typeof t === \"string\") {                                                                         // 81\n      result[parts.join(\"/\")] = t;                                                                              // 82\n    }                                                                                                           // 83\n  }                                                                                                             // 84\n                                                                                                                //\n  walk(tree);                                                                                                   // 86\n  return result;                                                                                                // 88\n}                                                                                                               // 89\n                                                                                                                //\nfunction makeModuleFunction(id, source, options) {                                                              // 91\n  // By calling (options && options.eval || eval) in a wrapper function,                                        // 92\n  // we delay the cost of parsing and evaluating the module code until the                                      // 93\n  // module is first imported.                                                                                  // 94\n  return function () {                                                                                          // 95\n    // If an options.eval function was provided in the second argument to                                       // 96\n    // meteorInstall when this bundle was first installed, use that                                             // 97\n    // function to parse and evaluate the dynamic module code in the scope                                      // 98\n    // of the package. Otherwise fall back to indirect (global) eval.                                           // 99\n    return (options && options.eval || eval)( // Wrap the function(require,exports,module){...} expression in   // 100\n    // parentheses to force it to be parsed as an expression.                                                   // 102\n    \"(\" + source + \")\\n//# sourceURL=\" + id).apply(this, arguments);                                            // 103\n  };                                                                                                            // 105\n}                                                                                                               // 106\n                                                                                                                //\nfunction fetchMissing(missingTree) {                                                                            // 108\n  // Update lastFetchMissingPromise immediately, without waiting for                                            // 109\n  // the results to be delivered.                                                                               // 110\n  return new Promise(function (resolve, reject) {                                                               // 111\n    Meteor.call(\"__dynamicImport\", missingTree, function (error, resultsTree) {                                 // 112\n      error ? reject(error) : resolve(resultsTree);                                                             // 116\n    });                                                                                                         // 117\n  });                                                                                                           // 119\n}                                                                                                               // 120\n                                                                                                                //\nfunction getFromTree(tree, id) {                                                                                // 122\n  id.split(\"/\").every(function (part) {                                                                         // 123\n    return !part || (tree = tree[part]);                                                                        // 124\n  });                                                                                                           // 125\n  return tree;                                                                                                  // 127\n}                                                                                                               // 128\n                                                                                                                //\nfunction addToTree(tree, id, value) {                                                                           // 130\n  var parts = id.split(\"/\");                                                                                    // 131\n  var lastIndex = parts.length - 1;                                                                             // 132\n  parts.forEach(function (part, i) {                                                                            // 133\n    if (part) {                                                                                                 // 134\n      tree = tree[part] = tree[part] || (i < lastIndex ? Object.create(null) : value);                          // 135\n    }                                                                                                           // 137\n  });                                                                                                           // 138\n}                                                                                                               // 139\n                                                                                                                //\nfunction getNamespace(module, id) {                                                                             // 141\n  var namespace;                                                                                                // 142\n  module.watch(module.require(id), {                                                                            // 144\n    \"*\": function (ns) {                                                                                        // 145\n      namespace = ns;                                                                                           // 146\n    }                                                                                                           // 147\n  }); // This helps with Babel interop, since we're not just returning the                                      // 144\n  // module.exports object.                                                                                     // 151\n                                                                                                                //\n  Object.defineProperty(namespace, \"__esModule\", {                                                              // 152\n    value: true,                                                                                                // 153\n    enumerable: false                                                                                           // 154\n  });                                                                                                           // 152\n  return namespace;                                                                                             // 157\n}                                                                                                               // 158\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"dynamic-versions.js\":function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                              //\n// packages/dynamic-import/dynamic-versions.js                                                                  //\n//                                                                                                              //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                //\n// This magic double-underscored identifier gets replaced in                                                    // 1\n// tools/isobuild/bundler.js with a tree of hashes of all dynamic                                               // 2\n// modules, for use in client.js and cache.js.                                                                  // 3\nmodule.exports = __DYNAMIC_VERSIONS__;                                                                          // 4\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"security.js\":function(require,exports,module){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                              //\n// packages/dynamic-import/security.js                                                                          //\n//                                                                                                              //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                //\nvar bpc = Package[\"browser-policy-content\"];                                                                    // 1\nvar BP = bpc && bpc.BrowserPolicy;                                                                              // 2\nvar BPc = BP && BP.content;                                                                                     // 3\n                                                                                                                //\nif (BPc) {                                                                                                      // 4\n  // The ability to evaluate new code is essential for loading dynamic                                          // 5\n  // modules. Without eval, we would be forced to load modules using                                            // 6\n  // <script src=...> tags, and then there would be no way to save those                                        // 7\n  // modules to a local cache (or load them from the cache) without the                                         // 8\n  // unique response caching abilities of service workers, which are not                                        // 9\n  // available in all browsers, and cannot be polyfilled in a way that                                          // 10\n  // satisfies Content Security Policy eval restrictions. Moreover, eval                                        // 11\n  // allows us to evaluate dynamic module code in the original package                                          // 12\n  // scope, which would never be possible using <script> tags. If you're                                        // 13\n  // deploying an app in an environment that demands a Content Security                                         // 14\n  // Policy that forbids eval, your only option is to bundle all dynamic                                        // 15\n  // modules in the initial bundle. Fortunately, that works perfectly                                           // 16\n  // well; you just won't get the performance benefits of dynamic module                                        // 17\n  // fetching.                                                                                                  // 18\n  BPc.allowEval();                                                                                              // 19\n}                                                                                                               // 20\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\nvar exports = require(\"./node_modules/meteor/dynamic-import/server.js\");\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage['dynamic-import'] = exports;\n\n})();\n","servePath":"/packages/dynamic-import.js","sourceMap":{"version":3,"sources":["packages/dynamic-import/server.js","packages/dynamic-import/cache.js","packages/dynamic-import/client.js","packages/dynamic-import/dynamic-versions.js","packages/dynamic-import/security.js"],"names":["module1","module","assert","watch","require","v","readFileSync","pathJoin","pathNormalize","join","normalize","check","hasOwn","Object","prototype","hasOwnProperty","keys","dynamicImportInfo","forEach","info","platform","dynamicRoot","Meteor","methods","__dynamicImport","tree","unblock","connection","pathParts","walk","node","push","name","strictEqual","pop","read","absPath","replace","startsWith","Error","cache","getCache","call","cachesByPlatform","create","process","on","msg","refresh","dbPromise","canUseCache","isClient","isCordova","isProduction","getIDB","indexedDB","webkitIndexedDB","mozIndexedDB","OIndexedDB","msIndexedDB","withDB","callback","Promise","resolve","reject","idb","request","open","onupgradeneeded","event","db","target","result","Array","from","objectStoreNames","deleteObjectStore","objectStoreMap","createObjectStore","onerror","makeOnError","onsuccess","then","error","sourcesByVersion","keyPath","source","JSON","stringify","checkCount","exports","checkMany","versions","ids","sourcesById","id","txn","transaction","objectStore","finish","all","map","version","sourceRequest","get","pendingVersionsAndSourcesById","setMany","versionsAndSourcesById","assign","flushSetMany","timer","setTimeout","setTxn","put","Module","constructor","dynamicImport","prefetch","getNamespace","meteorInstall","fetch","dynamicVersions","missing","getFromTree","addToTree","sources","makeModuleFunction","options","fetchMissing","results","flatResults","flattenModuleTree","parts","t","key","eval","apply","arguments","missingTree","resultsTree","split","every","part","value","lastIndex","length","i","namespace","ns","defineProperty","enumerable","__DYNAMIC_VERSIONS__","bpc","Package","BP","BrowserPolicy","BPc","content","allowEval"],"mappings":"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","file":"/packages/dynamic-import.js","sourcesContent":["import assert from \"assert\";\nimport { readFileSync } from \"fs\";\nimport {\n  join as pathJoin,\n  normalize as pathNormalize,\n} from \"path\";\n\nimport { check } from \"meteor/check\";\n\nimport \"./security.js\";\nimport \"./client.js\";\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nObject.keys(dynamicImportInfo).forEach(platform => {\n  const info = dynamicImportInfo[platform];\n  if (info.dynamicRoot) {\n    info.dynamicRoot = pathNormalize(info.dynamicRoot);\n  }\n});\n\nMeteor.methods({\n  __dynamicImport(tree) {\n    check(tree, Object);\n    this.unblock();\n\n    const platform = this.connection ? \"web.browser\" : \"server\";\n    const pathParts = [];\n\n    function walk(node) {\n      if (node && typeof node === \"object\") {\n        Object.keys(node).forEach(name => {\n          pathParts.push(name);\n          node[name] = walk(node[name]);\n          assert.strictEqual(pathParts.pop(), name);\n        });\n      } else {\n        return read(pathParts, platform);\n      }\n      return node;\n    }\n\n    return walk(tree);\n  }\n});\n\nfunction read(pathParts, platform) {\n  const { dynamicRoot } = dynamicImportInfo[platform];\n  const absPath = pathNormalize(pathJoin(\n    dynamicRoot,\n    pathJoin(...pathParts).replace(/:/g, \"_\")\n  ));\n\n  if (! absPath.startsWith(dynamicRoot)) {\n    throw new Meteor.Error(\"bad dynamic module path\");\n  }\n\n  const cache = getCache(platform);\n  return hasOwn.call(cache, absPath)\n    ? cache[absPath]\n    : cache[absPath] = readFileSync(absPath, \"utf8\");\n}\n\nconst cachesByPlatform = Object.create(null);\nfunction getCache(platform) {\n  return hasOwn.call(cachesByPlatform, platform)\n    ? cachesByPlatform[platform]\n    : cachesByPlatform[platform] = Object.create(null);\n}\n\nprocess.on(\"message\", msg => {\n  // The cache for the \"web.browser\" platform needs to be discarded\n  // whenever a client-only refresh occurs, so that new client code does\n  // not receive stale module data from __dynamicImport. This code handles\n  // the same message listened for by the autoupdate package.\n  if (msg && msg.refresh === \"client\") {\n    delete cachesByPlatform[\"web.browser\"];\n  }\n});\n","var hasOwn = Object.prototype.hasOwnProperty;\nvar dbPromise;\n\nvar canUseCache =\n  // The server doesn't benefit from dynamic module fetching, and almost\n  // certainly doesn't support IndexedDB.\n  Meteor.isClient &&\n  // Cordova bundles all modules into the monolithic initial bundle, so\n  // the dynamic module cache won't be necessary.\n  ! Meteor.isCordova &&\n  // Caching can be confusing in development, and is designed to be a\n  // transparent optimization for production performance.\n  Meteor.isProduction;\n\nfunction getIDB() {\n  if (typeof indexedDB !== \"undefined\") return indexedDB;\n  if (typeof webkitIndexedDB !== \"undefined\") return webkitIndexedDB;\n  if (typeof mozIndexedDB !== \"undefined\") return mozIndexedDB;\n  if (typeof OIndexedDB !== \"undefined\") return OIndexedDB;\n  if (typeof msIndexedDB !== \"undefined\") return msIndexedDB;\n}\n\nfunction withDB(callback) {\n  dbPromise = dbPromise || new Promise(function (resolve, reject) {\n    var idb = getIDB();\n    if (! idb) {\n      throw new Error(\"IndexedDB not available\");\n    }\n\n    // Incrementing the version number causes all existing object stores\n    // to be deleted and recreates those specified by objectStoreMap.\n    var request = idb.open(\"MeteorDynamicImportCache\", 2);\n\n    request.onupgradeneeded = function (event) {\n      var db = event.target.result;\n\n      // It's fine to delete existing object stores since onupgradeneeded\n      // is only called when we change the DB version number, and the data\n      // we're storing is disposable/reconstructible.\n      Array.from(db.objectStoreNames).forEach(db.deleteObjectStore, db);\n\n      Object.keys(objectStoreMap).forEach(function (name) {\n        db.createObjectStore(name, objectStoreMap[name]);\n      });\n    };\n\n    request.onerror = makeOnError(reject, \"indexedDB.open\");\n    request.onsuccess = function (event) {\n      resolve(event.target.result);\n    };\n  });\n\n  return dbPromise.then(callback, function (error) {\n    return callback(null);\n  });\n}\n\nvar objectStoreMap = {\n  sourcesByVersion: { keyPath: \"version\" }\n};\n\nfunction makeOnError(reject, source) {\n  return function (event) {\n    reject(new Error(\n      \"IndexedDB failure in \" + source + \" \" +\n        JSON.stringify(event.target)\n    ));\n\n    // Returning true from an onerror callback function prevents an\n    // InvalidStateError in Firefox during Private Browsing. Silencing\n    // that error is safe because we handle the error more gracefully by\n    // passing it to the Promise reject function above.\n    // https://github.com/meteor/meteor/issues/8697\n    return true;\n  };\n}\n\nvar checkCount = 0;\n\nexports.checkMany = function (versions) {\n  var ids = Object.keys(versions);\n  var sourcesById = Object.create(null);\n\n  // Initialize sourcesById with null values to indicate all sources are\n  // missing (unless replaced with actual sources below).\n  ids.forEach(function (id) {\n    sourcesById[id] = null;\n  });\n\n  if (! canUseCache) {\n    return Promise.resolve(sourcesById);\n  }\n\n  return withDB(function (db) {\n    if (! db) {\n      // We thought we could used IndexedDB, but something went wrong\n      // while opening the database, so err on the side of safety.\n      return sourcesById;\n    }\n\n    var txn = db.transaction([\n      \"sourcesByVersion\"\n    ], \"readonly\");\n\n    var sourcesByVersion = txn.objectStore(\"sourcesByVersion\");\n\n    ++checkCount;\n\n    function finish() {\n      --checkCount;\n      return sourcesById;\n    }\n\n    return Promise.all(ids.map(function (id) {\n      return new Promise(function (resolve, reject) {\n        var version = versions[id];\n        if (version) {\n          var sourceRequest = sourcesByVersion.get(versions[id]);\n          sourceRequest.onerror = makeOnError(reject, \"sourcesByVersion.get\");\n          sourceRequest.onsuccess = function (event) {\n            var result = event.target.result;\n            if (result) {\n              sourcesById[id] = result.source;\n            }\n            resolve();\n          };\n        } else resolve();\n      });\n    })).then(finish, finish);\n  });\n};\n\nvar pendingVersionsAndSourcesById = Object.create(null);\n\nexports.setMany = function (versionsAndSourcesById) {\n  if (canUseCache) {\n    Object.assign(\n      pendingVersionsAndSourcesById,\n      versionsAndSourcesById\n    );\n\n    // Delay the call to flushSetMany so that it doesn't contribute to the\n    // amount of time it takes to call module.dynamicImport.\n    if (! flushSetMany.timer) {\n      flushSetMany.timer = setTimeout(flushSetMany, 100);\n    }\n  }\n};\n\nfunction flushSetMany() {\n  if (checkCount > 0) {\n    // If checkMany is currently underway, postpone the flush until later,\n    // since updating the cache is less important than reading from it.\n    return flushSetMany.timer = setTimeout(flushSetMany, 100);\n  }\n\n  flushSetMany.timer = null;\n\n  var versionsAndSourcesById = pendingVersionsAndSourcesById;\n  pendingVersionsAndSourcesById = Object.create(null);\n\n  return withDB(function (db) {\n    if (! db) {\n      // We thought we could used IndexedDB, but something went wrong\n      // while opening the database, so err on the side of safety.\n      return;\n    }\n\n    var setTxn = db.transaction([\n      \"sourcesByVersion\"\n    ], \"readwrite\");\n\n    var sourcesByVersion = setTxn.objectStore(\"sourcesByVersion\");\n\n    return Promise.all(\n      Object.keys(versionsAndSourcesById).map(function (id) {\n        var info = versionsAndSourcesById[id];\n        return new Promise(function (resolve, reject) {\n          var request = sourcesByVersion.put({\n            version: info.version,\n            source: info.source\n          });\n          request.onerror = makeOnError(reject, \"sourcesByVersion.put\");\n          request.onsuccess = resolve;\n        });\n      })\n    );\n  });\n}\n","var Module = module.constructor;\nvar cache = require(\"./cache.js\");\n\n// Call module.dynamicImport(id) to fetch a module and any/all of its\n// dependencies that have not already been fetched, and evaluate them as\n// soon as they arrive. This runtime API makes it very easy to implement\n// ECMAScript dynamic import(...) syntax.\nModule.prototype.dynamicImport = function (id) {\n  var module = this;\n  return module.prefetch(id).then(function () {\n    return getNamespace(module, id);\n  });\n};\n\n// Called by Module.prototype.prefetch if there are any missing dynamic\n// modules that need to be fetched.\nmeteorInstall.fetch = function (ids) {\n  var tree = Object.create(null);\n  var versions = Object.create(null);\n  var dynamicVersions = require(\"./dynamic-versions.js\");\n  var missing;\n\n  Object.keys(ids).forEach(function (id) {\n    var version = getFromTree(dynamicVersions, id);\n    if (version) {\n      versions[id] = version;\n    } else {\n      addToTree(missing = missing || Object.create(null), id, 1);\n    }\n  });\n\n  return cache.checkMany(versions).then(function (sources) {\n    Object.keys(sources).forEach(function (id) {\n      var source = sources[id];\n      if (source) {\n        var info = ids[id];\n        addToTree(tree, id, makeModuleFunction(id, source, info.options));\n      } else {\n        addToTree(missing = missing || Object.create(null), id, 1);\n      }\n    });\n\n    return missing && fetchMissing(missing).then(function (results) {\n      var versionsAndSourcesById = Object.create(null);\n      var flatResults = flattenModuleTree(results);\n\n      Object.keys(flatResults).forEach(function (id) {\n        var source = flatResults[id];\n        var info = ids[id];\n\n        addToTree(tree, id, makeModuleFunction(id, source, info.options));\n\n        var version = getFromTree(dynamicVersions, id);\n        if (version) {\n          versionsAndSourcesById[id] = {\n            version: version,\n            source: source\n          };\n        }\n      });\n\n      cache.setMany(versionsAndSourcesById);\n    });\n\n  }).then(function () {\n    return tree;\n  });\n};\n\nfunction flattenModuleTree(tree) {\n  var parts = [\"\"];\n  var result = Object.create(null);\n\n  function walk(t) {\n    if (t && typeof t === \"object\") {\n      Object.keys(t).forEach(function (key) {\n        parts.push(key);\n        walk(t[key]);\n        parts.pop();\n      });\n    } else if (typeof t === \"string\") {\n      result[parts.join(\"/\")] = t;\n    }\n  }\n\n  walk(tree);\n\n  return result;\n}\n\nfunction makeModuleFunction(id, source, options) {\n  // By calling (options && options.eval || eval) in a wrapper function,\n  // we delay the cost of parsing and evaluating the module code until the\n  // module is first imported.\n  return function () {\n    // If an options.eval function was provided in the second argument to\n    // meteorInstall when this bundle was first installed, use that\n    // function to parse and evaluate the dynamic module code in the scope\n    // of the package. Otherwise fall back to indirect (global) eval.\n    return (options && options.eval || eval)(\n      // Wrap the function(require,exports,module){...} expression in\n      // parentheses to force it to be parsed as an expression.\n      \"(\" + source + \")\\n//# sourceURL=\" + id\n    ).apply(this, arguments);\n  };\n}\n\nfunction fetchMissing(missingTree) {\n  // Update lastFetchMissingPromise immediately, without waiting for\n  // the results to be delivered.\n  return new Promise(function (resolve, reject) {\n    Meteor.call(\n      \"__dynamicImport\",\n      missingTree,\n      function (error, resultsTree) {\n        error ? reject(error) : resolve(resultsTree);\n      }\n    );\n  });\n}\n\nfunction getFromTree(tree, id) {\n  id.split(\"/\").every(function (part) {\n    return ! part || (tree = tree[part]);\n  });\n\n  return tree;\n}\n\nfunction addToTree(tree, id, value) {\n  var parts = id.split(\"/\");\n  var lastIndex = parts.length - 1;\n  parts.forEach(function (part, i) {\n    if (part) {\n      tree = tree[part] = tree[part] ||\n        (i < lastIndex ? Object.create(null) : value);\n    }\n  });\n}\n\nfunction getNamespace(module, id) {\n  var namespace;\n\n  module.watch(module.require(id), {\n    \"*\": function (ns) {\n      namespace = ns;\n    }\n  });\n\n  // This helps with Babel interop, since we're not just returning the\n  // module.exports object.\n  Object.defineProperty(namespace, \"__esModule\", {\n    value: true,\n    enumerable: false\n  });\n\n  return namespace;\n}\n","// This magic double-underscored identifier gets replaced in\n// tools/isobuild/bundler.js with a tree of hashes of all dynamic\n// modules, for use in client.js and cache.js.\nmodule.exports = __DYNAMIC_VERSIONS__;\n","const bpc = Package[\"browser-policy-content\"];\nconst BP = bpc && bpc.BrowserPolicy;\nconst BPc = BP && BP.content;\nif (BPc) {\n  // The ability to evaluate new code is essential for loading dynamic\n  // modules. Without eval, we would be forced to load modules using\n  // <script src=...> tags, and then there would be no way to save those\n  // modules to a local cache (or load them from the cache) without the\n  // unique response caching abilities of service workers, which are not\n  // available in all browsers, and cannot be polyfilled in a way that\n  // satisfies Content Security Policy eval restrictions. Moreover, eval\n  // allows us to evaluate dynamic module code in the original package\n  // scope, which would never be possible using <script> tags. If you're\n  // deploying an app in an environment that demands a Content Security\n  // Policy that forbids eval, your only option is to bundle all dynamic\n  // modules in the initial bundle. Fortunately, that works perfectly\n  // well; you just won't get the performance benefits of dynamic module\n  // fetching.\n  BPc.allowEval();\n}\n"]}}]