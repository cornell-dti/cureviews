{"metadata":{"usedHelpers":["typeof","interopRequireDefault"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/dynamic-import/client.js","filenameRelative":"packages/dynamic-import/client.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/dynamic-import/client.js.map","sourceFileName":"packages/dynamic-import/client.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"client"},"ignored":false,"code":"var _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar Module = module.constructor;\n\nvar cache = require(\"./cache.js\"); // Call module.dynamicImport(id) to fetch a module and any/all of its\n// dependencies that have not already been fetched, and evaluate them as\n// soon as they arrive. This runtime API makes it very easy to implement\n// ECMAScript dynamic import(...) syntax.\n\n\nModule.prototype.dynamicImport = function (id) {\n  var module = this;\n  return module.prefetch(id).then(function () {\n    return getNamespace(module, id);\n  });\n}; // Called by Module.prototype.prefetch if there are any missing dynamic\n// modules that need to be fetched.\n\n\nmeteorInstall.fetch = function (ids) {\n  var tree = Object.create(null);\n  var versions = Object.create(null);\n\n  var dynamicVersions = require(\"./dynamic-versions.js\");\n\n  var missing;\n  Object.keys(ids).forEach(function (id) {\n    var version = getFromTree(dynamicVersions, id);\n\n    if (version) {\n      versions[id] = version;\n    } else {\n      addToTree(missing = missing || Object.create(null), id, 1);\n    }\n  });\n  return cache.checkMany(versions).then(function (sources) {\n    Object.keys(sources).forEach(function (id) {\n      var source = sources[id];\n\n      if (source) {\n        var info = ids[id];\n        addToTree(tree, id, makeModuleFunction(id, source, info.options));\n      } else {\n        addToTree(missing = missing || Object.create(null), id, 1);\n      }\n    });\n    return missing && fetchMissing(missing).then(function (results) {\n      var versionsAndSourcesById = Object.create(null);\n      var flatResults = flattenModuleTree(results);\n      Object.keys(flatResults).forEach(function (id) {\n        var source = flatResults[id];\n        var info = ids[id];\n        addToTree(tree, id, makeModuleFunction(id, source, info.options));\n        var version = getFromTree(dynamicVersions, id);\n\n        if (version) {\n          versionsAndSourcesById[id] = {\n            version: version,\n            source: source\n          };\n        }\n      });\n      cache.setMany(versionsAndSourcesById);\n    });\n  }).then(function () {\n    return tree;\n  });\n};\n\nfunction flattenModuleTree(tree) {\n  var parts = [\"\"];\n  var result = Object.create(null);\n\n  function walk(t) {\n    if (t && (typeof t === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(t)) === \"object\") {\n      Object.keys(t).forEach(function (key) {\n        parts.push(key);\n        walk(t[key]);\n        parts.pop();\n      });\n    } else if (typeof t === \"string\") {\n      result[parts.join(\"/\")] = t;\n    }\n  }\n\n  walk(tree);\n  return result;\n}\n\nfunction makeModuleFunction(id, source, options) {\n  // By calling (options && options.eval || eval) in a wrapper function,\n  // we delay the cost of parsing and evaluating the module code until the\n  // module is first imported.\n  return function () {\n    // If an options.eval function was provided in the second argument to\n    // meteorInstall when this bundle was first installed, use that\n    // function to parse and evaluate the dynamic module code in the scope\n    // of the package. Otherwise fall back to indirect (global) eval.\n    return (options && options.eval || eval)( // Wrap the function(require,exports,module){...} expression in\n    // parentheses to force it to be parsed as an expression.\n    \"(\" + source + \")\\n//# sourceURL=\" + id).apply(this, arguments);\n  };\n}\n\nfunction fetchMissing(missingTree) {\n  // Update lastFetchMissingPromise immediately, without waiting for\n  // the results to be delivered.\n  return new Promise(function (resolve, reject) {\n    Meteor.call(\"__dynamicImport\", missingTree, function (error, resultsTree) {\n      error ? reject(error) : resolve(resultsTree);\n    });\n  });\n}\n\nfunction getFromTree(tree, id) {\n  id.split(\"/\").every(function (part) {\n    return !part || (tree = tree[part]);\n  });\n  return tree;\n}\n\nfunction addToTree(tree, id, value) {\n  var parts = id.split(\"/\");\n  var lastIndex = parts.length - 1;\n  parts.forEach(function (part, i) {\n    if (part) {\n      tree = tree[part] = tree[part] || (i < lastIndex ? Object.create(null) : value);\n    }\n  });\n}\n\nfunction getNamespace(module, id) {\n  var namespace;\n  module.watch(module.require(id), {\n    \"*\": function (ns) {\n      namespace = ns;\n    }\n  }); // This helps with Babel interop, since we're not just returning the\n  // module.exports object.\n\n  Object.defineProperty(namespace, \"__esModule\", {\n    value: true,\n    enumerable: false\n  });\n  return namespace;\n}","map":{"version":3,"sources":["packages/dynamic-import/client.js"],"names":["Module","module","constructor","cache","require","prototype","dynamicImport","id","prefetch","then","getNamespace","meteorInstall","fetch","ids","tree","Object","create","versions","dynamicVersions","missing","keys","forEach","version","getFromTree","addToTree","checkMany","sources","source","info","makeModuleFunction","options","fetchMissing","results","versionsAndSourcesById","flatResults","flattenModuleTree","setMany","parts","result","walk","t","key","push","pop","join","eval","apply","arguments","missingTree","Promise","resolve","reject","Meteor","call","error","resultsTree","split","every","part","value","lastIndex","length","i","namespace","watch","ns","defineProperty","enumerable"],"mappings":"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","file":"packages/dynamic-import/client.js.map","sourcesContent":["var Module = module.constructor;\nvar cache = require(\"./cache.js\");\n\n// Call module.dynamicImport(id) to fetch a module and any/all of its\n// dependencies that have not already been fetched, and evaluate them as\n// soon as they arrive. This runtime API makes it very easy to implement\n// ECMAScript dynamic import(...) syntax.\nModule.prototype.dynamicImport = function (id) {\n  var module = this;\n  return module.prefetch(id).then(function () {\n    return getNamespace(module, id);\n  });\n};\n\n// Called by Module.prototype.prefetch if there are any missing dynamic\n// modules that need to be fetched.\nmeteorInstall.fetch = function (ids) {\n  var tree = Object.create(null);\n  var versions = Object.create(null);\n  var dynamicVersions = require(\"./dynamic-versions.js\");\n  var missing;\n\n  Object.keys(ids).forEach(function (id) {\n    var version = getFromTree(dynamicVersions, id);\n    if (version) {\n      versions[id] = version;\n    } else {\n      addToTree(missing = missing || Object.create(null), id, 1);\n    }\n  });\n\n  return cache.checkMany(versions).then(function (sources) {\n    Object.keys(sources).forEach(function (id) {\n      var source = sources[id];\n      if (source) {\n        var info = ids[id];\n        addToTree(tree, id, makeModuleFunction(id, source, info.options));\n      } else {\n        addToTree(missing = missing || Object.create(null), id, 1);\n      }\n    });\n\n    return missing && fetchMissing(missing).then(function (results) {\n      var versionsAndSourcesById = Object.create(null);\n      var flatResults = flattenModuleTree(results);\n\n      Object.keys(flatResults).forEach(function (id) {\n        var source = flatResults[id];\n        var info = ids[id];\n\n        addToTree(tree, id, makeModuleFunction(id, source, info.options));\n\n        var version = getFromTree(dynamicVersions, id);\n        if (version) {\n          versionsAndSourcesById[id] = {\n            version: version,\n            source: source\n          };\n        }\n      });\n\n      cache.setMany(versionsAndSourcesById);\n    });\n\n  }).then(function () {\n    return tree;\n  });\n};\n\nfunction flattenModuleTree(tree) {\n  var parts = [\"\"];\n  var result = Object.create(null);\n\n  function walk(t) {\n    if (t && typeof t === \"object\") {\n      Object.keys(t).forEach(function (key) {\n        parts.push(key);\n        walk(t[key]);\n        parts.pop();\n      });\n    } else if (typeof t === \"string\") {\n      result[parts.join(\"/\")] = t;\n    }\n  }\n\n  walk(tree);\n\n  return result;\n}\n\nfunction makeModuleFunction(id, source, options) {\n  // By calling (options && options.eval || eval) in a wrapper function,\n  // we delay the cost of parsing and evaluating the module code until the\n  // module is first imported.\n  return function () {\n    // If an options.eval function was provided in the second argument to\n    // meteorInstall when this bundle was first installed, use that\n    // function to parse and evaluate the dynamic module code in the scope\n    // of the package. Otherwise fall back to indirect (global) eval.\n    return (options && options.eval || eval)(\n      // Wrap the function(require,exports,module){...} expression in\n      // parentheses to force it to be parsed as an expression.\n      \"(\" + source + \")\\n//# sourceURL=\" + id\n    ).apply(this, arguments);\n  };\n}\n\nfunction fetchMissing(missingTree) {\n  // Update lastFetchMissingPromise immediately, without waiting for\n  // the results to be delivered.\n  return new Promise(function (resolve, reject) {\n    Meteor.call(\n      \"__dynamicImport\",\n      missingTree,\n      function (error, resultsTree) {\n        error ? reject(error) : resolve(resultsTree);\n      }\n    );\n  });\n}\n\nfunction getFromTree(tree, id) {\n  id.split(\"/\").every(function (part) {\n    return ! part || (tree = tree[part]);\n  });\n\n  return tree;\n}\n\nfunction addToTree(tree, id, value) {\n  var parts = id.split(\"/\");\n  var lastIndex = parts.length - 1;\n  parts.forEach(function (part, i) {\n    if (part) {\n      tree = tree[part] = tree[part] ||\n        (i < lastIndex ? Object.create(null) : value);\n    }\n  });\n}\n\nfunction getNamespace(module, id) {\n  var namespace;\n\n  module.watch(module.require(id), {\n    \"*\": function (ns) {\n      namespace = ns;\n    }\n  });\n\n  // This helps with Babel interop, since we're not just returning the\n  // module.exports object.\n  Object.defineProperty(namespace, \"__esModule\", {\n    value: true,\n    enumerable: false\n  });\n\n  return namespace;\n}\n"]},"hash":"e7c920b086bc9954be6f6253bc6493f5814ed998"}
