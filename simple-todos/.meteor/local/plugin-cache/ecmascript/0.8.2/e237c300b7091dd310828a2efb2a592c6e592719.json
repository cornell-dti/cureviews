{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/dynamic-import/security.js","filenameRelative":"packages/dynamic-import/security.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/dynamic-import/security.js.map","sourceFileName":"packages/dynamic-import/security.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"security"},"ignored":false,"code":"var bpc = Package[\"browser-policy-content\"];\nvar BP = bpc && bpc.BrowserPolicy;\nvar BPc = BP && BP.content;\n\nif (BPc) {\n  // The ability to evaluate new code is essential for loading dynamic\n  // modules. Without eval, we would be forced to load modules using\n  // <script src=...> tags, and then there would be no way to save those\n  // modules to a local cache (or load them from the cache) without the\n  // unique response caching abilities of service workers, which are not\n  // available in all browsers, and cannot be polyfilled in a way that\n  // satisfies Content Security Policy eval restrictions. Moreover, eval\n  // allows us to evaluate dynamic module code in the original package\n  // scope, which would never be possible using <script> tags. If you're\n  // deploying an app in an environment that demands a Content Security\n  // Policy that forbids eval, your only option is to bundle all dynamic\n  // modules in the initial bundle. Fortunately, that works perfectly\n  // well; you just won't get the performance benefits of dynamic module\n  // fetching.\n  BPc.allowEval();\n}","map":{"version":3,"sources":["packages/dynamic-import/security.js"],"names":["bpc","Package","BP","BrowserPolicy","BPc","content","allowEval"],"mappings":"AAAA,IAAMA,MAAMC,QAAQ,wBAAR,CAAZ;AACA,IAAMC,KAAKF,OAAOA,IAAIG,aAAtB;AACA,IAAMC,MAAMF,MAAMA,GAAGG,OAArB;;AACA,IAAID,GAAJ,EAAS;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAIE,SAAJ;AACD","file":"packages/dynamic-import/security.js.map","sourcesContent":["const bpc = Package[\"browser-policy-content\"];\nconst BP = bpc && bpc.BrowserPolicy;\nconst BPc = BP && BP.content;\nif (BPc) {\n  // The ability to evaluate new code is essential for loading dynamic\n  // modules. Without eval, we would be forced to load modules using\n  // <script src=...> tags, and then there would be no way to save those\n  // modules to a local cache (or load them from the cache) without the\n  // unique response caching abilities of service workers, which are not\n  // available in all browsers, and cannot be polyfilled in a way that\n  // satisfies Content Security Policy eval restrictions. Moreover, eval\n  // allows us to evaluate dynamic module code in the original package\n  // scope, which would never be possible using <script> tags. If you're\n  // deploying an app in an environment that demands a Content Security\n  // Policy that forbids eval, your only option is to bundle all dynamic\n  // modules in the initial bundle. Fortunately, that works perfectly\n  // well; you just won't get the performance benefits of dynamic module\n  // fetching.\n  BPc.allowEval();\n}\n"]},"hash":"e237c300b7091dd310828a2efb2a592c6e592719"}
